package org.vaadin.addons.logview.filter;

import java.util.prefs.Preferences;

import org.vaadin.addons.logview.LogViewComponent;

import com.vaadin.annotations.AutoGenerated;
import com.vaadin.data.Container;
import com.vaadin.data.util.HierarchicalContainer;
import com.vaadin.event.Action;
import com.vaadin.event.DataBoundTransferable;
import com.vaadin.event.ItemClickEvent;
import com.vaadin.event.MouseEvents.ClickEvent;
import com.vaadin.event.Transferable;
import com.vaadin.event.dd.DragAndDropEvent;
import com.vaadin.event.dd.DropHandler;
import com.vaadin.event.dd.acceptcriteria.AcceptAll;
import com.vaadin.event.dd.acceptcriteria.AcceptCriterion;
import com.vaadin.terminal.gwt.client.ui.dd.VerticalDropLocation;
import com.vaadin.ui.AbstractSelect.AbstractSelectTargetDetails;
import com.vaadin.ui.CheckBox;
import com.vaadin.ui.Component;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.Field;
import com.vaadin.ui.Table.TableDragMode;
import com.vaadin.ui.TableFieldFactory;
import com.vaadin.ui.Tree;
import com.vaadin.ui.Tree.CollapseEvent;
import com.vaadin.ui.Tree.ExpandEvent;
import com.vaadin.ui.TreeTable;
import com.vaadin.ui.VerticalLayout;

public class FilterComponent extends CustomComponent {
	@AutoGenerated
	private VerticalLayout mainLayout;

	@AutoGenerated
	private TreeTable treetable;

	private final FilterEntryHelper helper;

	private static final Action ADD_ITEM_ACTION = new Action("Add Item");

	private static final Action ADD_CATEGORY_ACTION = new Action("Add Category");

	private static final Action REMOVE_ITEM_ACTION = new Action("Remove");

	private static final Action EDIT_ITEM_ACTION = new Action("Edit");

	public FilterComponent(LogViewComponent logView, Preferences sharedPrefs, Preferences tabPrefs) {
		buildMainLayout();
		setCompositionRoot(mainLayout);

		helper = new FilterEntryHelper(logView, treetable, sharedPrefs, tabPrefs);

		// Add Table columns
		treetable.addContainerProperty(FilterEntryHelper.NAME_PROPERTY, String.class, "");
		treetable.addContainerProperty(FilterEntryHelper.ACTIVE_PROPERTY, Boolean.class, false);
		treetable.addContainerProperty(FilterEntryHelper.REGEX_PROPERTY, String.class, "");
		treetable.setTableFieldFactory(new TableFieldFactory() {
			@Override
			public Field createField(Container container, Object itemId, Object propertyId, Component uiContext) {
				if(FilterEntryHelper.ACTIVE_PROPERTY.equals(propertyId)) {
					CheckBox ret = new CheckBox();
					if(treetable.areChildrenAllowed(itemId)) {
						ret.setVisible(false);
					} else {
						ret.setImmediate(true);
					}
					return ret;
				}
				return null;
			}
		});
		treetable.setDragMode(TableDragMode.ROW);
		treetable.setDropHandler(new DropHandler() {
			@Override
			public AcceptCriterion getAcceptCriterion() {
				return AcceptAll.get();
			}

			@Override
			public void drop(DragAndDropEvent dropEvent) {
				// Called whenever a drop occurs on the component

				// Make sure the drag source is the same tree
				Transferable t = dropEvent.getTransferable();

				// see the comment in getAcceptCriterion()
				if(t.getSourceComponent() != treetable || !(t instanceof DataBoundTransferable)) {
					return;
				}

				AbstractSelectTargetDetails dropData = ((AbstractSelectTargetDetails)dropEvent.getTargetDetails());

				Object sourceItemId = ((DataBoundTransferable)t).getItemId();
				// FIXME: Why "over", should be "targetItemId" or just
				// "getItemId"
				Object targetItemId = dropData.getItemIdOver();

				// Location describes on which part of the node the drop took
				// place
				VerticalDropLocation location = dropData.getDropLocation();

				moveNode(sourceItemId, targetItemId, location);
				helper.save();
				treetable.refreshRowCache();
			}
		});

		treetable.addListener(new ItemClickEvent.ItemClickListener() {
			@Override
			public void itemClick(ItemClickEvent event) {
				if(event.getButton() == ClickEvent.BUTTON_LEFT && event.isDoubleClick()) {
					showSettings(event.getItemId());
				}
			}
		});

		treetable.addListener(new Tree.CollapseListener() {
			@Override
			public void nodeCollapse(CollapseEvent event) {
				helper.save();
			}
		});

		treetable.addListener(new Tree.ExpandListener() {
			@Override
			public void nodeExpand(ExpandEvent event) {
				helper.save();
			}
		});

		treetable.addActionHandler(new Action.Handler() {
			@Override
			public void handleAction(Action action, Object sender, Object target) {
				if(action == ADD_ITEM_ACTION) {
					helper.newItem();
				} else if(action == ADD_CATEGORY_ACTION) {
					helper.newCategory();
				} else if(action == REMOVE_ITEM_ACTION) {
					helper.remove(target);
				} else if(action == EDIT_ITEM_ACTION) {
					// showSettings(target);
					System.err.println(target);
				} else {
					getWindow().showNotification("Action " + action.toString());
				}
			}

			@Override
			public Action[] getActions(Object target, Object sender) {

				if(target == null) {
					// Context menu in an empty space -> add a new main category
					return new Action[] {
						ADD_CATEGORY_ACTION
					};

				} else if(treetable.areChildrenAllowed(target)) {
					// Context menu for a category
					return new Action[] {
						ADD_CATEGORY_ACTION, ADD_ITEM_ACTION, REMOVE_ITEM_ACTION
					};

				} else {
					// Context menu for an item
					return new Action[] {
						EDIT_ITEM_ACTION, REMOVE_ITEM_ACTION
					};
				}
			}
		});

		treetable.setSortDisabled(true);
		treetable.setHierarchyColumn(FilterEntryHelper.NAME_PROPERTY);
		treetable.setColumnWidth(FilterEntryHelper.ACTIVE_PROPERTY, 25);
		treetable.setColumnHeader(FilterEntryHelper.ACTIVE_PROPERTY, "");
		treetable.setVisibleColumns(new String[] {
			FilterEntryHelper.ACTIVE_PROPERTY, FilterEntryHelper.NAME_PROPERTY
		});
		treetable.setEditable(true);

		helper.load();
		treetable.refreshRowCache();
	}

	@SuppressWarnings("unused")
	protected void showSettings(Object id) {
		if(helper.isCategory(id)) {
			new CategorySettings(getWindow(), treetable.getItem(id));
		} else {
			new FilterSettings(getWindow(), treetable.getItem(id));
		}
		helper.save();
	}

	/**
	 * Move a node within a tree onto, above or below another node depending
	 * on the drop location.
	 * 
	 * @param sourceItemId
	 *            id of the item to move
	 * @param targetItemId
	 *            id of the item onto which the source node should be moved
	 * @param location
	 *            VerticalDropLocation indicating where the source node was
	 *            dropped relative to the target node
	 */
	private void moveNode(Object sourceItemId, Object targetItemId, VerticalDropLocation location) {
		HierarchicalContainer container = (HierarchicalContainer)treetable.getContainerDataSource();

		// Sorting goes as
		// - If dropped ON a node, we append it as a child
		// - If dropped on the TOP part of a node, we move/add it before
		// the node
		// - If dropped on the BOTTOM part of a node, we move/add it
		// after the node

		if(location == VerticalDropLocation.MIDDLE) {
			if(container.setParent(sourceItemId, targetItemId) && container.hasChildren(targetItemId)) {
				// move first in the container
				container.moveAfterSibling(sourceItemId, null);
			}
		} else if(location == VerticalDropLocation.TOP) {
			Object parentId = container.getParent(targetItemId);
			if(container.setParent(sourceItemId, parentId)) {
				// reorder only the two items, moving source above target
				container.moveAfterSibling(sourceItemId, targetItemId);
				container.moveAfterSibling(targetItemId, sourceItemId);
			}
		} else if(location == VerticalDropLocation.BOTTOM) {
			Object parentId = container.getParent(targetItemId);
			if(container.setParent(sourceItemId, parentId)) {
				container.moveAfterSibling(sourceItemId, targetItemId);
			}
		}
	}

	@AutoGenerated
	private VerticalLayout buildMainLayout() {
		// common part: create layout
		mainLayout = new VerticalLayout();
		mainLayout.setImmediate(false);
		mainLayout.setWidth("100%");
		mainLayout.setHeight("100%");
		mainLayout.setMargin(false);

		// top-level component properties
		setWidth("100.0%");
		setHeight("100.0%");

		// treetable
		treetable = new TreeTable();
		treetable.setImmediate(false);
		treetable.setWidth("100.0%");
		treetable.setHeight("100.0%");
		mainLayout.addComponent(treetable);

		return mainLayout;
	}

	public void updateTabFilter() {
		helper.updateTabFilter();
	}
}
