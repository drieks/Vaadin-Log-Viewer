package org.vaadin.addons.logview.filter;

import java.util.prefs.Preferences;

import org.vaadin.addons.logview.LogViewComponent;

import com.vaadin.annotations.AutoGenerated;
import com.vaadin.data.Container;
import com.vaadin.data.Item;
import com.vaadin.event.Action;
import com.vaadin.event.DataBoundTransferable;
import com.vaadin.event.ItemClickEvent;
import com.vaadin.event.MouseEvents.ClickEvent;
import com.vaadin.event.Transferable;
import com.vaadin.event.dd.DragAndDropEvent;
import com.vaadin.event.dd.DropHandler;
import com.vaadin.event.dd.acceptcriteria.AcceptAll;
import com.vaadin.event.dd.acceptcriteria.AcceptCriterion;
import com.vaadin.terminal.gwt.client.ui.dd.VerticalDropLocation;
import com.vaadin.ui.AbstractSelect.AbstractSelectTargetDetails;
import com.vaadin.ui.CheckBox;
import com.vaadin.ui.Component;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.Field;
import com.vaadin.ui.Root;
import com.vaadin.ui.Table.TableDragMode;
import com.vaadin.ui.TableFieldFactory;
import com.vaadin.ui.Tree;
import com.vaadin.ui.Tree.CollapseEvent;
import com.vaadin.ui.Tree.ExpandEvent;
import com.vaadin.ui.TreeTable;
import com.vaadin.ui.VerticalLayout;

public class FilterComponent extends CustomComponent {
	@AutoGenerated
	private VerticalLayout mainLayout;

	@AutoGenerated
	private TreeTable treetable;

	// private final FilterEntryHelper helper;

	private static final Action ADD_ITEM_ACTION = new Action("Add Item");

	private static final Action ADD_GROUP_ACTION = new Action("Add Group");

	private static final Action REMOVE_ACTION = new Action("Remove");

	private static final Action EDIT_ACTION = new Action("Edit");

	private final FilterSettingContainer container;

	public FilterComponent(LogViewComponent logView, Preferences sharedPrefs, Preferences tabPrefs) {
		buildMainLayout();
		setCompositionRoot(mainLayout);

		container = new FilterSettingContainer(treetable);

		/*
		helper = new FilterEntryHelper(logView, treetable, sharedPrefs, tabPrefs);
		helper = new FilterEntryHelper(treetable);
		 */

		treetable.setTableFieldFactory(new TableFieldFactory() {
			@Override
			public Field<?> createField(Container container, Object itemId, Object propertyId, Component uiContext) {
				if(FilterSettingContainer.ACTIVE.equals(propertyId)) {
					CheckBox ret = new CheckBox();
					ret.setImmediate(true);
					return ret;
				}
				return null;
			}
		});
		treetable.setDragMode(TableDragMode.ROW);
		treetable.setDropHandler(new DropHandler() {
			@Override
			public AcceptCriterion getAcceptCriterion() {
				return AcceptAll.get();
			}

			@Override
			public void drop(DragAndDropEvent dropEvent) {
				// Called whenever a drop occurs on the component

				// Make sure the drag source is the same tree
				Transferable t = dropEvent.getTransferable();

				// see the comment in getAcceptCriterion()
				if(t.getSourceComponent() != treetable || !(t instanceof DataBoundTransferable)) {
					return;
				}

				AbstractSelectTargetDetails dropData = ((AbstractSelectTargetDetails)dropEvent.getTargetDetails());

				Object sourceItemId = ((DataBoundTransferable)t).getItemId();
				// FIXME: Why "over", should be "targetItemId" or just
				// "getItemId"
				Object targetItemId = dropData.getItemIdOver();

				// Location describes on which part of the node the drop took
				// place
				VerticalDropLocation location = dropData.getDropLocation();

				moveNode(sourceItemId, targetItemId, location);
				// helper.save();
				container.update();
				System.err.println(container.toString());
			}
		});

		treetable.addListener(new ItemClickEvent.ItemClickListener() {
			@Override
			public void itemClick(ItemClickEvent event) {
				if(event.getButton() == ClickEvent.BUTTON_LEFT && event.isDoubleClick()) {
					showSettings(event.getItemId());
				}
			}
		});

		treetable.addListener(new Tree.CollapseListener() {
			@Override
			public void nodeCollapse(CollapseEvent event) {
				// helper.save();
			}
		});

		treetable.addListener(new Tree.ExpandListener() {
			@Override
			public void nodeExpand(ExpandEvent event) {
				// helper.save();
			}
		});

		treetable.addActionHandler(new Action.Handler() {
			@Override
			public void handleAction(Action action, Object sender, Object target) {
				if(action == ADD_ITEM_ACTION || action == ADD_GROUP_ACTION) {
					FilterSettingData item = container.addItem();
					container.setParent(item, target);
					// item.setParent((FilterSettingData)target);
					if(action == ADD_ITEM_ACTION) {
						item.setName("Item");
					} else {
						item.setChildrenAllowed(true);
						item.setName("Group");
					}
				} else if(action == REMOVE_ACTION) {
					container.removeItem(target);
				} else if(action == EDIT_ACTION) {
					showSettings(target);
				} else {
					getRoot().showNotification("Action " + action.toString());
				}
				container.update();
			}

			@Override
			public Action[] getActions(Object target, Object sender) {
				if(target == null) {
					// Context menu in an empty space -> add a new main category
					return new Action[] {
						ADD_ITEM_ACTION, ADD_GROUP_ACTION
					};
				} else if(((FilterSettingData)target).areChildrenAllowed()) {
					// Context menu for an group
					return new Action[] {
						ADD_ITEM_ACTION, EDIT_ACTION, REMOVE_ACTION
					};
				} else {
					// Context menu for an item
					return new Action[] {
						EDIT_ACTION, REMOVE_ACTION
					};
				}
			}
		});

		treetable.setSortDisabled(true);
		treetable.setEditable(true);

		// helper.load();
		treetable.refreshRowCache();
	}

	protected void showSettings(Object id) {
		Item item = treetable.getItem(id);
		Root.getCurrentRoot().addWindow(new FilterSettingsWindow(item, container));
		// helper.save();
	}

	/**
	 * Move a node within a tree onto, above or below another node depending
	 * on the drop location.
	 * 
	 * @param sourceItemId
	 *            id of the item to move
	 * @param targetItemId
	 *            id of the item onto which the source node should be moved
	 * @param location
	 *            VerticalDropLocation indicating where the source node was
	 *            dropped relative to the target node
	 */
	private void moveNode(Object sourceItemId, Object targetItemId, VerticalDropLocation location) {
		// Sorting goes as
		// - If dropped ON a node, we append it as a child
		// - If dropped on the TOP part of a node, we move/add it before
		// the node
		// - If dropped on the BOTTOM part of a node, we move/add it
		// after the node

		if(location == VerticalDropLocation.MIDDLE) {
			if(container.areChildrenAllowed(targetItemId) && container.setParent(sourceItemId, targetItemId)
					&& container.hasChildren(targetItemId)) {
				// move first in the container
				container.moveAfterSibling(sourceItemId, null);
			}
		} else if(location == VerticalDropLocation.TOP) {
			Object parentId = container.getParent(targetItemId);
			if(container.setParent(sourceItemId, parentId)) {
				// reorder only the two items, moving source above target
				container.moveAfterSibling(sourceItemId, targetItemId);
				container.moveAfterSibling(targetItemId, sourceItemId);
			}
		} else if(location == VerticalDropLocation.BOTTOM) {
			Object parentId = container.getParent(targetItemId);
			if(container.setParent(sourceItemId, parentId)) {
				container.moveAfterSibling(sourceItemId, targetItemId);
			}
		}
	}

	@AutoGenerated
	private VerticalLayout buildMainLayout() {
		// common part: create layout
		mainLayout = new VerticalLayout();
		mainLayout.setImmediate(false);
		mainLayout.setWidth("100%");
		mainLayout.setHeight("100%");
		mainLayout.setMargin(false);

		// top-level component properties
		setWidth("100.0%");
		setHeight("100.0%");

		// treetable
		treetable = new TreeTable();
		treetable.setImmediate(true);
		treetable.setWidth("100.0%");
		treetable.setHeight("100.0%");
		mainLayout.addComponent(treetable);

		return mainLayout;
	}

	public void updateTabFilter() {
		// helper.updateTabFilter();
	}
}
